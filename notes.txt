Phase 1: User Info & Management
GET /me — Get current user info
PUT /me — Update user info (name, email, password)
DELETE /me — Delete own account

Backend:

Implement GET /me to return the current user’s info (such as id, name, email, avatar, role, etc.).
Implement PUT /me to allow the user to update their info. Validate input with zod and log any changes for auditing.
Implement DELETE /me to let the user delete their own account. Use a soft delete (mark as deleted, don’t remove from DB) and log the deletion for audit purposes.
Make sure all /me endpoints are protected with JWT authentication middleware.
Only return the necessary user info—never send sensitive fields like passwords or tokens.
Add documentation for these endpoints in Swagger.
Apply rate limiting to the PUT and DELETE endpoints to prevent abuse.

Frontend:

Use GET /me to fetch and display user info after login (profile details, avatar, role, etc.).
Use PUT /me to send updated profile data to the backend when the user edits their profile.
Use DELETE /me to confirm and send a delete request; after deletion, log out the user and redirect them appropriately.
Handle 401 responses: if the JWT is expired or invalid, log out the user and redirect to the login page.
Validate input on the frontend before sending it to the backend (ideally using the same rules as zod).
Only display allowed user info on the frontend—never show sensitive data.

Phase 2: RBAC (Role-Based Access Control)
GET /roles — List roles (admin only)
GET /users — List all users (admin only)
GET /users/:id — Get user by ID (admin only)
PUT /users/:id/role — Change user role (admin only)
DELETE /users/:id — Delete user by ID (admin only)

Backend

Add a role field to the User model (e.g., enum: 'user' | 'admin').
Update registration logic to assign user role by default.
Create middleware to check user roles (e.g., authorizeRole('admin')).
Implement GET /roles endpoint (admin only).
Implement PUT /users/:id/role endpoint to change user roles (admin only).
Implement GET /users endpoint to list all users (admin only).
Implement GET /users/:id endpoint to get user by ID (admin only).
Implement DELETE /users/:id endpoint to delete user by ID (admin only).
Add audit logging for all role changes and user management actions.
Add Swagger documentation for all new endpoints.
Add rate limiting to sensitive admin endpoints.

Frontend

Add logic to fetch current user’s role after login (from /me).
Implement route guards to restrict admin pages to users with admin role.
Create an Admin Page with:
List of all users (GET /users)
Ability to change user roles (PUT /users/:id/role)
Ability to delete users (DELETE /users/:id)
Display available roles (from GET /roles) in role management UI.
Show error messages for forbidden actions (403) and conflicts (409).
Hide admin features from non-admin users in the UI.
Validate input before sending role changes or deletions.
Handle 401/403 responses by redirecting or showing appropriate messages.

Phase 3: Session Management

Backend

- Add Session model to DB (id, userId, createdAt, lastUsedAt, ipAddress, userAgent, deviceName, location, oauthProvider, refreshToken, isRevoked).
- Create session on login (store all info above).
- Implement GET /sessions endpoint (list all active sessions for current user).
- Implement DELETE /sessions/:sessionId endpoint (revoke session).
- Implement POST /sessions/logout-all endpoint (revoke all sessions for user).
- Implement PUT /sessions/:sessionId endpoint (update session info (e.g., rename device, mark as trusted).).
- Update middleware to check session validity (isRevoked, expiry).
- On refresh, rotate refresh token and update session.
- Prevent use of revoked/expired sessions for API or refresh.

- Add audit logging for session actions (creation, revocation, suspicious activity).
- Document endpoints in Swagger.

Frontend

- Fetch and display sessions in user profile/security page.
- Add "Log out" button for each session.
- Add "Log out from all devices" button.
- Handle session revocation and expired tokens (auto-logout, redirect).
- Show device info, last activity, location if possible.
- Educate users about session management and security.
- Handle edge cases (e.g., cannot revoke current session, show error).

Advanced/optional features:

    Device fingerprinting (identify devices more reliably, e.g., using user agent, IP, or hardware info).

Edge cases to handle (step by step):

    Track and display device info and location (show user which devices are logged in, and where).
    Rate limit session endpoints (protect session management endpoints from abuse).

Step-by-step:
6. On logout:
    - Revoke session in DB.
    - Invalidate refresh token.
7. OAuth login:
    - After OAuth callback, create/find user, create session, issue JWTs.

Phase 4: Security & Audit (NOT STARTED)

GET /audit-logs — List audit logs (admin only)
POST /change-password — Change password

Backend

Design and add an AuditLog model to your database
    Fields: id, userId, action, status, timestamp, ipAddress, userAgent, details (optional)

Implement audit logging logic
    Log key actions: login, logout, password change, session creation/revocation, role changes, suspicious activity, account changes

Create GET /audit-logs endpoint (admin only)
    Return paginated list of audit logs, filter by user, action, date, etc.

Log the password change in audit logs

Add audit logging to all sensitive endpoints
    Include user info, action, status, device info, and details

Protect audit log endpoints with RBAC middleware
    Only allow admins to access GET /audit-logs

Add Swagger/OpenAPI documentation for new endpoints
Add rate limiting to /change-password and /audit-logs endpoints

Frontend

Add "Change Password" form in user profile/settings
    Call POST /change-password, handle errors and success

Create an Audit Log page for admins
    Fetch and display logs from GET /audit-logs
    Add filters (by user, action, date)

Show clear error/success messages for password changes and audit log actions
Hide audit log features from non-admin users
Handle 401/403 responses by redirecting or showing appropriate messages

Phase 5: 2FA (Optional, Advanced)
POST /2fa/setup — Setup 2FA
POST /2fa/verify — Verify 2FA code
POST /2fa/disable — Disable 2FA

Phase 6: Email & Account Verification

Backend

- POST /email/change — Request email change (authenticated user)
    - Require authentication.
    - Validate new email (format, uniqueness).
    - Generate a verification token and expiration.
    - Save pendingEmail (recommended), activationToken, and activationExpires to the user.
    - Send a verification email to the new address with a link containing the token.
    - (If you choose not to add pendingEmail, be aware of the risk of overwriting the current email before verification.)

- POST /email/verify — Verify new email
    - Accept the verification token (from email link).
    - Find the user by token and check expiration.
    - If valid, update the user’s email to pendingEmail (if used), clear the pending fields, and set isActivated: true.
    - Invalidate all sessions (optional, for security).
    - Respond with success or error.

- Block email change until user verifies their account (recommended and standard).
- Only allow email change for users with isActivated: true.
- Prevent changing to an email already in use.

- Rate limit email change requests.
- Log all email change requests and verifications (audit logging).
- Document both endpoints and their flows in Swagger/OpenAPI.

Frontend

- Add "Change Email" UI in user profile/settings.
    - Validate email format before sending.
    - On form submit, call POST /email/change.
    - Show feedback: “Verification email sent to your new address.”

- Handle verification link:
    - Create a route/page for /email/verify?token=...
    - On page load, call POST /email/verify with the token from the URL.
    - Show success or error message based on backend response.

- Show loading and error states for both requests.
- Optionally, show the current email and pending email (if any).
- Optionally, allow resending the verification email.
- After successful verification, log the user out or refresh their session (if required by backend).
- Show clear messages for expired/invalid tokens, already-used emails, etc.













Phase 7: OAuth/Social Login (Optional, Advanced)
GET /oauth/:provider — Start OAuth flow
GET /oauth/:provider/callback — Handle OAuth callback

Phase 8: Other Features
Add rate limiting, account lockout, error handling, logging, and Swagger docs as you go.

Phase 9: Advanced RBAC Features

- Permission-based RBAC: Move beyond simple roles to granular permissions (e.g., canEditUser, canDeleteUser).
- Hierarchical roles: Support role inheritance (e.g., superadmin inherits admin permissions).
- Dynamic roles & permissions: Manage roles/permissions via UI or API, store in database.
- Resource-based permissions: Scope permissions to specific resources (e.g., canEditProject:123).
- Attribute-Based Access Control (ABAC): Make access decisions based on user/resource/context attributes.
- Policy engines: Integrate with tools like Casbin or Oso for flexible, declarative access control.
- Delegated administration: Allow scoped admin powers (e.g., department or team admins).
- Multi-tenancy support: Isolate roles and permissions per tenant/organization.
- UI for role & permission management: Build admin UI for managing roles, permissions, assignments.
- Permission caching: Cache permissions for performance, invalidate on changes.
- Permission testing: Automated tests to ensure permissions are enforced correctly.
- Temporary roles/permissions: Support time-limited access (e.g., grant admin for 24 hours).
- Impersonation: Allow admins to impersonate users for troubleshooting (with audit logging).
- Integration with external identity providers: Sync roles/permissions from LDAP, SAML, OAuth, etc.

--------------------------

What’s Missing or Worth Adding?

/resend-verification-code → In case user didn’t receive the email.
/deactivate-account or /delete-account → GDPR compliance.
Rate limiting & IP tracking → Already partially covered with limiter, but consider per-user limits.
